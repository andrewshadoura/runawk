=head1 NAME

runawk - wrapper for AWK interpreter

=head1 SYNOPSIS

B<runawk> I<[options]> I<program_file>

B<runawk> I<-e> I<program>

=head1 DESCRIPTION

After years of using AWK for programming I've found that despite of
its simplicity and limitations AWK is good enough for scripting a wide
range of different tasks. AWK is not as poweful as their bigger
counterparts like Perl, Ruby, TCL and others but it has their own
advantages like compactness, simplicity and availability on almost all
UNIX-like systems. I personally also like its data-driven nature and
token orientation, very useful technique for simple text processing
utilities.

But! Unfortunately awk interpreters lacks some important features and
sometimes work not as good as it whould be.

Problems I see (some of them, of course)

=over 2

=item 1

AWK lacks support for modules. Even if I create small programs, I
often want to use the functions created earlier and already used in
other scripts. That is, it whould great to orginise functions into
so called libraries (modules).

=item 2

In order to pass arguments to C<#!/usr/bin/awk -f> script (not to awk
interpreter), it is necessary to prepand a list of
arguments with -- (two minus signes). In my view, this looks badly.

Example:

awk_program:

    #!/usr/bin/awk -f

    BEGIN {
       for (i=1; i < ARGC; ++i){
          printf "ARGV [%d]=%s\n", i, ARGV [i]
       }
    }

Shell session:

    % awk_program --opt1 --opt2
    /usr/bin/awk: unknown option --opt1 ignored

    /usr/bin/awk: unknown option --opt2 ignored

    % awk_program -- --opt1 --opt2
    ARGV [1]=--opt1
    ARGV [2]=--opt2
    %

In my opinion I<awk_program> script should work like this

    % awk_program --opt1 --opt2
    ARGV [1]=--opt1
    ARGV [2]=--opt2
    %

It is possible using B<runawk>.

=item 3

When C<#!/usr/bin/awk -f> script handles arguments (options) and wants
to read from stdin, it is necessary to add
/dev/stdin (or `-') as a last argument explicitly.

Example:

awk_program:

    #!/usr/bin/awk -f

    BEGIN {
       if (ARGV [1] == "--flag"){
          flag = 1
          ARGV [1] = "" # to not read file named "--flag"
       }
    }

    {
       print "flag=" flag " $0=" $0
    }

Shell session:

    % echo test | awk_program -- --flag
    % echo test | awk_program -- --flag /dev/stdin
    flag=1 $0=test
    %

Ideally I<awk_program> should work like this

    % echo test | awk_program --flag
    flag=1 $0=test
    %

=back

B<runawk> was created to solve all these problems

=head1 OPTIONS

=over 6

=item B<-h>|B<--help>

Display help information.

=item B<-V>|B<--version>

Display version information.

=item B<-d>|B<--debug>

Turn on a debugging mode in which B<runawk> prints argument list
with which real B<awk> interpreter will be run.

=item B<-i>|B<--with-stdin>

Add stdin file name to a list of awk arguments

=item B<-I>|B<--without-stdin>

Do not add stdin file name to a list of awk arguments (the default)

=item B<-e>|B<--execute> I<program>

Specify program. If I<-e> is not specified program is read from
I<program_file>.

=back

=head1 DETAILS/INTERNALS

=head2 Standalone script

Under UNIX-like OS-es you can use B<runawk>
by beginning your script with

   #!/usr/local/bin/runawk

line or something like this instead of

   #!/usr/bin/awk -f

or similar.

=head2 AWK modules

In order to activate modules you should add them into awk script like this

  #use "module1.awk"
  #use "module2.awk"

that is the line that specifies module name is treated as a comment line
by normal AWK interpreter but is processed by B<runawk> especially.

Note that I<#use> should begin with column 0,
no spaces are allowed before it and no spaces are allowed between
I<#> and I<use>.

Also note that AWK modules can also "use" another modules and so forth.
All them are collected in a depth-first order
and each one is added to the list of
awk interpreter arguments prepanded with -f option.
That is I<#use> directive is *NOT* similar to I<#include> in 
C programming language,
runawk's module code is not inserted into the place of I<#use>.
Runawk's modules are closer to Perl's "use" command.
In case some module is mentioned more than once, only one -f
will be added for it, i.e duplications are removed automatically.

Position of I<#use> directive in a source file does matter, i.e.
the earlier module is mentioned, the earlier -f will be generated for it.

Example:

  file prog:
     #!/usr/local/bin/runawk

     #use "A.awk"
     #use "B.awk"
     #use "E.awk"

     PROG code
     ...

  file B.awk:
     #use "A.awk"
     #use "C.awk"
     B code
     ...

  file C.awk:
     #use "A.awk"
     #use "D.awk"

     C code
     ...

  A.awk and D.awk don't contain #use directive

If you run

  runawk prog file1 file2

or

  /path/to/prog file1 file2

the following command

  awk -f A.awk -f D.awk -f C.awk -f B.awk -f E.awk -f prog -- file1 file2

will actually run.

You can check this by running

  runawk -d prog file1 file2

=head2 Module search strategy

Modules are first searched in a directory where main
program (or module in which #use directive is specified) is placed.
If it is not found there, then
AWKPATH environment variable is
checked. AWKPATH keeps a colon separated
list of search directories.
Finally, module is searched in system runawk modules directory,
by default PREFIX/share/runawk but this can be changed at build time.

An absolute path of the module can also be specified.

=head2 AWK interpreter and its arguments

In order to pass arguments to AWK script correctly, B<runawk>
treats their arguments beginning with `-' sign (minus) especially.
The following command

  runawk prog2 -x -f=file -o=output file1 file2

or

  /path/to/prog2 -x -f=file -o=output file1 file2

will actually run

  awk -f prog2 -- -x -f=file -o=output file1 file2

therefore -s, -f, -o options will be passed to ARGV/ARGC awk's variables
together with file1 and file2. If all arguments begin with `-' (minus),
B<runawk> will add stdin filename to the end of argument list,
(unless -I option is specified) i.e. running

  runawk prog3 --value=value

or

  /path/to/prog3 --value=value

will actually run the following

  awk -f prog3 -- --value=value /dev/stdin

=head2 Program as an argument

Like some other interpreters
B<runawk> can obtain the script from a command line like this

 /path/to/runawk -e '
 #use "alt_assert.awk"

 {
   assert($1 >= 0 && $1 <= 10, "Bad value: " $1)

   # your code below
   ...
 }'

=head2 Selecting a preferred AWK interpreter

For some reason you may prefer one AWK interpreter or another with a help of
I<#interp> command like this

  file prog:
     #!/usr/local/bin/runawk

     #use "A.awk"
     #use "B.awk"

     #interp "/usr/pkg/bin/nbawk"

     # your code here
     ...

The reason may be efficiency for a particular task, useful but
not standard extensions or enything else.

Note that I<#interp> directive should also begin with column 0,
no spaces are allowed before it and between I<#> and I<interp>.

=head2 Setting environment

In some cases you may want to run AWK interpreter with a
specific environment. For example, your script may be oriented to
process ASCII text only. In this case you can run AWK with LC_CTYPE=C
environment and use regexp ranges.

B<runawk> provides I<#env> directive for this. String inside double quotes
is passed to L<putenv(3)> libc function.

Example:

  file prog:
     #!/usr/local/bin/runawk

     #env "LC_ALL=C"

     $1 ~ /^[A-Z]+$/ { # A-Z is valid if LC_CTYPE=C
         print $1
     }

=head1 EXIT STATUS

If AWK interpreter exits normally, B<runawk> exits with its exit
status. If AWK interpreter was killed by signal, B<runawk>
exits with exit status 128+signal.

=head1 ENVIRONMENT

=over 6

=item I<AWKPATH>

Colon separated list of directories where B<awk> modules are searched.

=item I<RUNAWK_AWKPROG>

Sets the path to the AWK interpreter, used by default,
i.e. this variable overrides the compile-time default.
Note that #interp directive overrides this.

=back

=head1 AUTHOR/LICENSE

Copyright (c) 2007-2008 Aleksey Cheusov <vle@gmx.net>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=head1 BUGS/FEEDBACK

Please send any comments, questions, bug reports etc. to me by e-mail
or (even better) register them at sourceforge project home.  Feature
requests are also welcomed.

=head1 HOME

L<http://sourceforge.net/projects/runawk>

=head1 SEE ALSO
L<awk(1)>
